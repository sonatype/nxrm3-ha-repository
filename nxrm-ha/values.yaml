# Declare variables to be passed into your templates.
namespaces:
  nexusNs:
    enabled: true
    name: "nexusrepo"
  cloudwatchNs:
    enabled: false
    name: amazon-cloudwatch
  externaldnsNs: nexus-externaldns
  certmanagerNs:
    name: "cert-manager"
externaldns:
  image: k8s.gcr.io/external-dns/external-dns:v0.13.1
certmanager:
  letsencrypt:
    enabled: false # set to true to indicate that you're using letsencrypt as the CA (See https://letsencrypt.org/ and https://cert-manager.io/docs/tutorials/)
    # service account details for ACME DNS01 challenge
    # See https://letsencrypt.org/docs/challenge-types/#dns-01-challenge for more information
    # See https://cert-manager.io/docs/tutorials/getting-started-aws-letsencrypt/#create-an-iam-role-and-associate-it-with-a-kubernetes-service-account for AWS example
    dns01Challenge:
      serviceAccount:
        name: "cert-manager-acme-dns01" # service account for ACME DNS01 challenge
        enabled: false
        annotations:
          eks.amazonaws.com/role-arn: arn:aws:iam::000000000000:role/cert-manager-acme-dns01
      rbac:
        enabled: false
        role:
          name: cert-manager-acme-dns01-route53-tokenrequest
        roleBinding:
          name: cert-manager-acme-dns01-route53-tokenrequest

serviceAccount:
  enabled: false
  name: nexus-repository-deployment-sa #This service account in managed by Helm
  labels: {}
  annotations:
    # Set annotations for service account. E.g. if deploying to AWS EKS
    # and secrets manager is enabled then this role should have permissions for using secret manager.
    # If using externaldns, role with route53 permissions needed by external-dns
    # eks.amazonaws.com/role-arn: arn:aws:iam::000000000000:role/nxrm-nexus-role
  externaldns:
    name: nexus-repository-dev-ha-externaldns
    annotations:
      eks.amazonaws.com/role-arn: arn:aws:iam::000000000000:role/external-dns-role
azure:
  enabled: false  #set to true to enable azure specific yamls/snippets
  keyvault:
    enabled: false # set to true to pull license, db and nexus admin password secrets from azure key vault
aws:
  enabled: false #set to true to enable aws specific yamls like external dns and fluent bit
  clusterRegion: us-east-1
  secretmanager:
    enabled: false # set to true to pull license, db and nexus admin password secrets from aws secret manager
  externaldns:
    enabled: false
    domainFilter: nexusrepo.com #your root domain e.g nexusrepo.com
    awsZoneType: private # hosted zone to look at (valid values are public, private or no value for both)
  fluentbit:
    enabled: false #set this to true to enable sending of logs to CloudWatch
    fluentBitVersion: 2.28.0
    clusterName: nxrm-nexus
statefulset:
  name: nxrm-statefulset
  serviceName: nxrm-statefulset-service
  replicaCount: 3
  clustered: true
  additionalVolumes:
  additionalVolumeMounts:
  additionalContainers:
  # # Add annotations to statefulset to enhance configurations
  annotations: {}
  podAnnotations: {}
  nodeSelector: {}
  # hostAliases allows the modification of the hosts file inside a container
  hostAliases: []
  # - ip: "192.168.1.10"
  #   hostnames:
  #   - "nexusrepo.com"
  #   - "www.nexusrepo.com"

  # Uncomment and modify this to run a command after starting the nexus container.
  postStart:
    command: null   # '["/bin/sh", "-c", "ls"]'
  preStart:
    command: null

  # # Add init containers. e.g. to be used to give specific permissions for nexus-data.
  # # Add your own init containers as needed
  initContainers:
    # chown nexus-data to 'nexus' user and init log directories/files for a new pod
    # otherwise the side car containers will crash a couple of times and backoff whilst waiting
    # for nxrm-app to start and this increases the total start up time.
    - name: chown-nexusdata-owner-to-nexus-and-init-log-dir
      image: busybox:1.33.1
      command: [/bin/sh]
      args:
        - -c
        - >-
          mkdir -p /nexus-data/etc/logback &&
          mkdir -p /nexus-data/log/tasks &&
          mkdir -p /nexus-data/log/audit &&
          touch -a /nexus-data/log/tasks/allTasks.log &&
          touch -a /nexus-data/log/audit/audit.log &&
          touch -a /nexus-data/log/request.log &&
          chown -R '200:200' /nexus-data
      volumeMounts:
        - name: nexus-data
          mountPath: /nexus-data
      resources:
        limits:
          cpu: "0.2"
          memory: "512Mi"
        requests:
          cpu: "0.1"
          memory: "256Mi"
  container:
    image:
      repository: sonatype/nexus3
      nexusTag: 3.74.0
    resources:
      # See help documentation, these are minimum system requirements
      requests:
        cpu: 8
        memory: "8Gi"
      limits:
        cpu: 16
        memory: "16Gi"
    containerPort: 8081
    pullPolicy: IfNotPresent
    terminationGracePeriod: 120
    env:
      nexusDBName: nexus
      nexusDBPort: 5432
      install4jAddVmParams: "-Xms2703m -Xmx2703m"
      jdbcUrlParams: null # Must start with a '?' e.g. "?foo=bar&baz=foo"
      zeroDowntimeEnabled: false
    additionalEnv: null
  requestLogContainer:
    image:
      repository: busybox
      tag: 1.33.1
    resources:
      limits:
        cpu: "0.2"
        memory: "512Mi"
      requests:
        cpu: "0.1"
        memory: "256Mi"
  auditLogContainer:
    image:
      repository: busybox
      tag: 1.33.1
    resources:
      limits:
        cpu: "0.2"
        memory: "512Mi"
      requests:
        cpu: "0.1"
        memory: "256Mi"
  taskLogContainer:
    image:
      repository: busybox
      tag: 1.33.1
    resources:
      limits:
        cpu: "0.2"
        memory: "512Mi"
      requests:
        cpu: "0.1"
        memory: "256Mi"
  startupProbe: # Allow up to 30 minutes for the container to finish any pending DB migration. Once the startup probe succeeds the liveness- and readiness probes get activated (no need for initialDelaySeconds).
    initialDelaySeconds: 0
    periodSeconds: 10
    timeoutSeconds: 1
    failureThreshold: 180
    path: /
  livenessProbe:
    initialDelaySeconds: 0
    periodSeconds: 60
    timeoutSeconds: 1
    failureThreshold: 6
    path: /
  readinessProbe:
    initialDelaySeconds: 0
    periodSeconds: 60
    timeoutSeconds: 1
    failureThreshold: 6
    path: /
  imagePullSecrets: {}
ingress:
  name: "nexus-ingress"
  enabled: false
  host: null # host to apply this ingress rule to e.g. www.nexusrepo.com. Set it as you wish. must match hosts in tls section
  hostPath: /
  dockersubdomain: false
  dockersubdomains:
#    - dockerrepo1.nexusrepo.com
#    - dockerrepo2.nexusrepo.com
#    - dockerrepo3.nexusrepo.com
  subdomainWildcard: true # Creates a wildcard rule in your ingress for docker subdomain routing. This will result in the creation of routing rules in your load balancer for sub domains of your host. Thus, you must also set the host
  defaultRule: false
  additionalRules: null
  ingressClassName: null # e.g. nginx, alb
#  tls:
#    - secretName: "nexusrepo-example-cert-2048" The name of the secret to store the certificate. Use this same name for the certificate.nexus.secretName to secure the certificate with this certificate
#      hosts:
#      - www.nexusrepo.com must match hosts in ingress.host
#      - nexusrepo.com you can put an additional rule which routes to the same backend service for this host as well
#      - dockerrepo1.nexusrepo.com
#      - dockerrepo2.nexusrepo.com
#      - dockerrepo3.nexusrepo.com
#    - secretName: "tlsSecretName1"
#      hosts:
#        - repo.foo2
#        - repo.bar2
#    - secretName: "tlsSecretName2"
#      hosts:
#        - repo.foo2
#        - repo.bar2
  annotations:
#  Note: the annotations below are just a guide; delete or insert more as needed depending on your use case: aws, azure, on prem
#    nginx.ingress.kubernetes.io/ssl-redirect: "false"
#    nginx.ingress.kubernetes.io/proxy-body-size: "0" # For docker push to work when using nginx. See https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#custom-max-body-size for more info
    #    alb.ingress.kubernetes.io/scheme: internal # scheme
#    alb.ingress.kubernetes.io/subnets: subnet-1,subnet-2 #comma separated list of subnet ids
    # alb.ingress.kubernetes.io/listen-ports: '[{"HTTPS":443}]'
    # alb.ingress.kubernetes.io/certificate-arn: arn:aws:acm:us-east-1:0000000000000:certificate/00000000-1111-2222-3333-444444444444  # The AWS Certificate Manager ARN for your HTTPS certificate
#    alb.ingress.kubernetes.io/certificate-arn: arn:aws:acm:us-east-1:0000000000000:certificate/00000000-1111-2222-3333-444444444444  # Comment out if you don't use docker repositories - The AWS Certificate Manager ARN for your HTTPS certificate
#    external-dns.alpha.kubernetes.io/hostname: dockerrepo1.nexusrepo.com, dockerrepo2.nexusrepo.com, dockerrepo3.nexusrepo.com
    # acme.cert-manager.io/http01-edit-in-place: "true" #See https://cert-manager.io/docs/usage/certificate/#issuance-behavior-temporary-certificates-while-issuing
logStorage:
  tailSecondaryLogs: true
  combineTaskLogs: true
storageClass:
  enabled: false # For built-in storage class, set storageClass.enabled to false
  name: nexus-storage # For built-in storage class, set storageClass.enabled to false and specify the name of the built-in storage class here e.g. managed-csi for AKS
  provisioner: provisionerName # To use your own storage class set storageClass.enabled to true and specify provisioner. E.g. for AKS use managed-csi. For AWS EKS: ebs.csi.aws.com. In case of AWS EKS cluster running version less than 1.23 use 'kubernetes.io/aws-ebs'
  volumeBindingMode: "WaitForFirstConsumer"
  reclaimPolicy: Retain
#  parameters:
#    type: type
#    fsType: "fsType" # e.g. ext4
#    iopsPerGB: "10"
pvc:
  accessModes: ReadWriteOnce # Set to ReadWriteMany if using EFS/Azure Files/NFS for shared log storage
  storage: 2Gi
  volumeClaimTemplate:
    enabled: false
  existingClaim: null

service:  #Nexus Repo NodePort Service
  annotations: {}
  nexus:
    enabled: false
    type: NodePort
    protocol: TCP
    port: 80
    targetPort: 8081
  headless:
    annotations: {}
    publishNotReadyAddresses: true # We want all pods in the StatefulSet to have their addresses published even before they're ready.
externalsecrets:
  enabled: false
  secretstore:
    name: nexus-secret-store
    spec:
      provider:
#        aws:
#          service: SecretsManager
#          region: us-east-1
#          auth:
#            jwt:
#              serviceAccountRef:
#                name: nexus-repository-deployment-sa # Use the same service account name as specified in serviceAccount.name
# Example for Azure
#    spec:
#      provider:
#        azurekv:
#          authType: WorkloadIdentity
#          vaultUrl: "https://xx-xxxx-xx.vault.azure.net"
#          serviceAccountRef:
#            name: nexus-repository-deployment-sa # Use the same service account name as specified in serviceAccount.name
# Example for Google (GCP)
#    spec:
#      provider:
#        gcpsm:
#          projectID: "nxrm-gcp-deployments"
#          auth:
#            workloadIdentity:
#              clusterLocation: "us-central1-a"
#              clusterName: "test-gke-cluster"
#              serviceAccountRef:
#                name: nexus-repository-deployment-sa
#                namespace: nexusrepo

  secrets:
    nexusSecret:
      enabled: false
      refreshInterval: 1h
      providerSecretName: nexus-secret.json
      decodingStrategy: null # For Azure set to Base64
    database:
      refreshInterval: 1h
      valueIsJson: false
      providerSecretName: dbSecretName # The name of the AWS SecretsManager/Azure KeyVault/etc. secret
      dbUserKey: username #  The name of the key in the secret that contains your database username
      dbPasswordKey: password # The name of the key in the secret that contains your database password
      dbHostKey: host # The name of the key in the secret that contains your database host
    admin:
      refreshInterval: 1h
      valueIsJson: false
      providerSecretName: adminSecretName # The name of the AWS SecretsManager/Azure KeyVault/etc. secret
      adminPasswordKey: "nexusAdminPassword" # The name of the key in the secret that contains your nexus repository admin password
    license:
      providerSecretName: nexus-repo-license.lic # The name of the AWS SecretsManager/Azure KeyVault/etc. secret that contains your Nexus Repository license
      decodingStrategy: null # Can be Base64
      refreshInterval: 1h
secret:
  secretProviderClass: "secretProviderClass"
  provider: provider # e.g. aws, azure etc
  dbSecret:
    enabled: false # Enable to apply database-secret.yaml which allows you to specify db credentials
  db:
    user: nxrm_db_user
    userAlias: nxrm_db_user_alias
    password: nxrm_db_password
    passwordAlias: nxrm_db_password_alias
    host: nxrm_db_host
    hostAlias: nxrm_db_host_alias
  nexusAdmin:
    name: "nexusAdminPassword"
    alias: "admin-nxrm-password-alias"
  nexusAdminSecret:
    enabled: false # Enable to apply nexus-admin-secret.yaml which allows you to the initial admin password for nexus repository
    adminPassword: yourinitialnexuspassword #You should change this when you login for the first time
  license:
    name: nexus-repo-license.lic
    licenseSecret:
      enabled: false
      file: # Specify the license file name with --set-file secret.license.licenseSecret.file="file_name" helm option
      fileContentsBase64: your_license_file_contents_in_base_64
      mountPath: /var/nexus-repo-license
  nexusSecret:
    enabled: false
    name: nexus-secret.json
    secretKeyfile: "secretfileName" # Specify the nexus secrets file name with --set-file secret.nexusSecret.secretKeyfile="file_name" helm option
    mountPath: /var/nexus-repo-secrets
  azure:
    # a managed identity or service principal that has secrets management access to the key vault
    userAssignedIdentityID: "userAssignedIdentityID"
    tenantId: "azureTenantId"
    keyvaultName: yourazurekeyvault
    useVMManagedIdentity: true
    usePodIdentity: false
    nexusSecret:
      enabled: false
  aws:
    license:
      arn: arn:aws:secretsmanager:us-east-1:000000000000:secret:nxrm-nexus-license
    nexusSecret:
      enabled: false
      arn: arn:aws:secretsmanager:us-east-1:000000000000:secret:nxrm-nexus-secrets-file
    adminpassword:
      arn: arn:aws:secretsmanager:us-east-1:000000000000:secret:admin-nxrm-password
    rds:
      arn: arn:aws:secretsmanager:us-east-1:000000000000:secret:nxrmrds-cred-nexus
nexus:
  # Default the pods UID and GID to match the nexus3 container.
  # Customize or remove these values from the securityContext as appropriate for
  # your deployment environment.
  securityContext:
    runAsUser: 200
  properties:
    override: false
    data: null # specify a list of key and values to override default nexus.properties
  extraLabels: {}
  extraSelectorLabels: {}
  docker:
    enabled: false
    createIngress: true #set to true to create dedicated ingresses for docker connector
    exposeDockerPorts: true
    createDockerRulesOnMainIngress: false
    type: NodePort
    protocol: TCP
#    registries:
#      - host: docker1.nexusrepo.com
#        port: 5000
#        secretName: nexusrepo-example-cert-2048
#        targetPort: 5000 # if using subdomains should be container port i.e. 8081
#        annotations: { }
#        enableTLS: true
#      - host: docker2.nexusrepo.com
#        port: 5001
#        secretName: nexusrepo-example-cert-2048
#        targetPort: 5001 # if using subdomains should be container port i.e. 8081
#        annotations: { }
#        enableTLS: true
certificate:
  apiVersion: cert-manager.io/v1
  enabled: false
  issuer:
    enabled: false
    group: cert-manager.io
    kind: ClusterIssuer
    name: demo-letsencrypt
    spec:
      acme:
        server: https://certificate-issuer-server-url # e.g. for letsencrypt https://acme-staging-v02.api.letsencrypt.org/directory
        email: email@example.com
        privateKeySecretRef:
          name: letsencrypt-staging
        solvers:
          - dns01:
#  Example for AWS Route53
#              route53:
#                region: us-east-1
#                # For AWS IAM Role which gives cert manager needed route 53 permissions.
#                # This must be the same role specified in certmanager.letsencrypt.dns01Challenge.serviceAccount.annotations
#                role: arn:aws:iam::111111111:role/cert-manager-acme-dns01
#                auth:
#                  kubernetes:
#                    serviceAccountRef:
#                      # The name of the K8 service account to use to gain needed permissions for the dns01 challenge
#                      # This must be the same service account specified in certmanager.letsencrypt.dns01Challenge.serviceAccount.name
#                      name: cert-manager-acme-dns01
#  Example for Azure DNS
#              azureDNS:
#                resourceGroupName: my-resource-group # your_own_resource_group_name which contains your DNS zone
#                subscriptionID: abcd1111-v511-1111-11ab-i111111yt111
#                hostedZoneName:  nexusrepo.com
#                environment: AzurePublicCloud
#                managedIdentity:
#                  clientID: 11111111-1111-1111-1111-111111111111
  nexus:
    enabled: false
    name: "nexusrepo-cert"
    commonName: "www.nexusrepo.com"
    duration: 2160h0m0s # 90 days
    renewBefore: 360h0m0s # 15 days
    secretName: nexusrepo-example-cert-2048 # The name of the secret to store the certificate. Use this same name for the ingress tls.secretName to secure the ingress with this certificate
    revisionHistoryLimit: 1
    secretTemplate: null
    privateKey:
      enabled: false
      algorithm: null # e.g. "RSA"
      encoding: null # e.g "PKCS1"
      size: null # e.g. 2048
      rotationPolicy: "Always"
    keystores: null
    usages:
      - digital signature
      - key encipherment
      - server auth
    subject: null
    dnsNames:
      - www.nexusrepo.com
      - nexusrepo.com
      - dockerrepo1.nexusrepo.com
      - dockerrepo2.nexusrepo.com
      - dockerrepo3.nexusrepo.com
    otherNames: null
    ipAddresses: null
    emailAddresses: null
    uris: null
    isCa: false

# Enable configmap and add arbitrary data in configmap
config:
  enabled: false
  mountPath: /sonatype-nexus-conf
  data: null
